# lib.r version="2.2.1"

#@author G. Le Corguille
#The function create a pdf from the different png generated by diffreport
diffreport_png2pdf <- function(filebase, new_file_path) {

  pdfEicOutput = paste(new_file_path,filebase,"-eic_visible_pdf",sep="")
  pdfBoxOutput = paste(new_file_path,filebase,"-box_visible_pdf",sep="")

  system(paste("gm convert ",filebase,"_eic/*.png ",filebase,"_eic.pdf",sep=""))
  system(paste("gm convert ",filebase,"_box/*.png ",filebase,"_box.pdf",sep=""))

  file.copy(paste(filebase,"_eic.pdf",sep=""), pdfEicOutput)
  file.copy(paste(filebase,"_box.pdf",sep=""), pdfBoxOutput)
}

#@author G. Le Corguille
#This function convert if it is required the Retention Time in minutes
RTSecondToMinute <- function(variableMetadata, convertRTMinute) {
    if (convertRTMinute){
        #converting the retention times (seconds) into minutes
        print("converting the retention times into minutes in the variableMetadata")
        variableMetadata[,"rt"]=variableMetadata[,"rt"]/60
        variableMetadata[,"rtmin"]=variableMetadata[,"rtmin"]/60
        variableMetadata[,"rtmax"]=variableMetadata[,"rtmax"]/60
    }
    return (variableMetadata)
}

#@author G. Le Corguille
#This function format ions identifiers
formatIonIdentifiers <- function(variableMetadata, numDigitsRT=0, numDigitsMZ=0) {
    splitDeco = strsplit(as.character(variableMetadata$name),"_")
    idsDeco = sapply(splitDeco, function(x) { deco=unlist(x)[2]; if (is.na(deco)) return ("") else return(paste0("_",deco)) })
    namecustom = make.unique(paste0("M",round(variableMetadata[,"mz"],numDigitsMZ),"T",round(variableMetadata[,"rt"],numDigitsRT),idsDeco))
    variableMetadata=cbind(name=variableMetadata$name, namecustom=namecustom, variableMetadata[,!(colnames(variableMetadata) %in% c("name"))])
    return(variableMetadata)
}

#The function annotateDiffreport without the corr function which bugs
annotatediff <- function(xset=xset, listArguments=listArguments, variableMetadataOutput="variableMetadata.tsv", dataMatrixOutput="dataMatrix.tsv",new_file_path=NULL) {
  # Resolve the bug with x11, with the function png
  options(bitmapType='cairo')

  #Check if the fillpeaks step has been done previously, if it hasn't, there is an error message and the execution is stopped.
  res=try(is.null(xset@filled))

  # ------ annot -------
  listArguments[["calcCiS"]]=as.logical(listArguments[["calcCiS"]])
  listArguments[["calcIso"]]=as.logical(listArguments[["calcIso"]])
  listArguments[["calcCaS"]]=as.logical(listArguments[["calcCaS"]])

  # parameters
  listArguments4annotate = c(
      object=xset,
      nSlaves=listArguments[["nSlaves"]],sigma=listArguments[["sigma"]],perfwhm=listArguments[["perfwhm"]],
      maxcharge=listArguments[["maxcharge"]],maxiso=listArguments[["maxiso"]],minfrac=listArguments[["minfrac"]],ppm=listArguments[["ppm"]],mzabs=listArguments[["mzabs"]],quick=listArguments[["quick"]],polarity=listArguments[["polarity"]],max_peaks=listArguments[["max_peaks"]],intval=listArguments[["intval"]]
    )
  
  if(listArguments[["quick"]]==TRUE) {
    listArguments4annotate = c(listArguments4annotate,
        graphMethod=listArguments[["graphMethod"]],cor_eic_th=listArguments[["cor_eic_th"]],pval=listArguments[["pval"]],calcCiS=listArguments[["calcCiS"]],calcIso=listArguments[["calcIso"]],calcCaS=listArguments[["calcCaS"]]
      )
    if (!is.null(listArguments[["multiplier"]]))
      listArguments4annotate = c(listArguments4annotate,
          multiplier=listArguments[["multiplier"]]
        )
    else
      listArguments4annotate = c(listArguments4annotate,
          rules=listArguments[["rules"]]
        )
  }


  
  # launch annotate
  xa = do.call("annotate", listArguments4annotate)
  peakList=getPeaklist(xa,intval=listArguments[["intval"]])
  peakList=cbind(groupnames(xa@xcmsSet),peakList); colnames(peakList)[1] = c("name");

  # --- dataMatrix ---
  dataMatrix = peakList[,(make.names(colnames(peakList)) %in% c("name", make.names(sampnames(xa@xcmsSet))))]
  write.table(dataMatrix, sep="\t", quote=FALSE, row.names=FALSE, file=dataMatrixOutput)


  # --- Multi condition : diffreport ---
  diffrep=NULL
  if (!is.null(listArguments[["runDiffreport"]]) & nlevels(sampclass(xset))>=2) {
    #Check if the fillpeaks step has been done previously, if it hasn't, there is an error message and the execution is stopped.
    res=try(is.null(xset@filled))
    classes=levels(sampclass(xset))
    x=1:(length(classes)-1)
    for (i in seq(along=x) ) {
      y=1:(length(classes))
      for (n in seq(along=y)){
        if(i+n <= length(classes)){
          filebase=paste(classes[i],class2=classes[i+n],sep="-vs-")

          diffrep=diffreport(object=xset,class1=classes[i],class2=classes[i+n],filebase=filebase,eicmax=listArguments[["eicmax"]],eicwidth=listArguments[["eicwidth"]],sortpval=TRUE,value=listArguments[["value"]],h=listArguments[["h"]],w=listArguments[["w"]],mzdec=listArguments[["mzdec"]])

          diffrepOri = diffrep

          # renamming of the column rtmed to rt to fit with camera peaklist function output
          colnames(diffrep)[colnames(diffrep)=="rtmed"] <- "rt"
          colnames(diffrep)[colnames(diffrep)=="mzmed"] <- "mz"

          # combines results and reorder columns
          diffrep = merge(peakList, diffrep[,c("name","fold","tstat","pvalue")], by.x="name", by.y="name", sort=F)
          diffrep = cbind(diffrep[,!(colnames(diffrep) %in% c(sampnames(xa@xcmsSet)))],diffrep[,(colnames(diffrep) %in% c(sampnames(xa@xcmsSet)))])

          diffrep = RTSecondToMinute(diffrep, listArguments[["convertRTMinute"]])
          diffrep = formatIonIdentifiers(diffrep, numDigitsRT=listArguments[["numDigitsRT"]], numDigitsMZ=listArguments[["numDigitsMZ"]])

          if(listArguments[["sortpval"]]){
            diffrep=diffrep[order(diffrep$pvalue), ]
          }

          write.table(diffrep, sep="\t", quote=FALSE, row.names=FALSE, file=paste(new_file_path,filebase,"-tabular_visible_tabular",sep=""))

          if (listArguments[["eicmax"]] != 0) {
              diffreport_png2pdf(filebase, new_file_path)
          }
        }
      }
    }
  }

  #grep  M213T3904 peakList*
  #peakList:184	M213T3904	212.800003051758	212.800003051758	212.800003051758	3904.42566271432	3904.42566271432	3904.42566271432	1	1	0	01230.08999999997	0	0			4788
  #peakList:192	M213T3904.1	213	213	213	3903.6249434652	3903.6249434652	3903.6249434652	1	1	0	1081.29983333335	0	700.103750256462	1711.00602968181	4804
  #peakListOri:184	M213T3904_1	212.800003051758	212.800003051758	212.800003051758	3904.42566271432	3904.42566271432	3904.42566271432	1	1	0	01230.08999999997	0	0			4788
  #peakListOri:192	M213T3904_2	213	213	213	3903.6249434652	3903.6249434652	3903.6249434652	1	1	0	1081.29983333335	0	700.103750256462	1711.00602968181	4804
  #grep  M213T3904 diffrep*
  #diffrep:1763	M213T3904	2.22982535057412	0.898369982214248	0.464165630574311	213	213	213	3903.6249434652	3903.6249434652	3903.6249434652	1	1	0	1081.29983333335	0	700.103750256462	1711.00602968181
  #diffrep:2100	M213T3904.1	Inf	-1	0.5	212.800003051758	212.800003051758	212.800003051758	3904.42566271432	3904.42566271432	3904.42566271432	110	0	1230.08999999997	0	0
  #diffrepOri:1763	M213T3904_2	2.22982535057412	0.898369982214248	0.464165630574311	213	213	213	3903.6249434652	3903.6249434652	3903.6249434652	1	1	0	1081.29983333335	0	700.103750256462	1711.00602968181
  #diffrepOri:2100	M213T3904_1	Inf	-1	0.5	212.800003051758	212.800003051758	212.800003051758	3904.42566271432	3904.42566271432	3904.42566271432	110	0	1230.08999999997	0	0


  # --- variableMetadata ---
  variableMetadata=peakList[,!(make.names(colnames(peakList)) %in% c(make.names(sampnames(xa@xcmsSet))))]
  variableMetadata = RTSecondToMinute(variableMetadata, listArguments[["convertRTMinute"]])
  variableMetadata = formatIonIdentifiers(variableMetadata, numDigitsRT=listArguments[["numDigitsRT"]], numDigitsMZ=listArguments[["numDigitsMZ"]])
  # if we have 2 conditions, we keep stat of diffrep
  if (!is.null(listArguments[["runDiffreport"]]) & nlevels(sampclass(xset))==2) {
    variableMetadata = merge(variableMetadata, diffrep[,c("name","fold","tstat","pvalue")],by.x="name", by.y="name", sort=F)
    if(exists("listArguments[[\"sortpval\"]]")){
      variableMetadata=variableMetadata[order(variableMetadata$pvalue), ]
    }
  }

  variableMetadataOri=variableMetadata
  write.table(variableMetadata, sep="\t", quote=FALSE, row.names=FALSE, file=variableMetadataOutput)

  return(list("xa"=xa,"diffrep"=diffrepOri,"variableMetadata"=variableMetadataOri));

}


combinexsAnnos_function <- function(xaP, xaN, listOFlistArgumentsP,listOFlistArgumentsN, diffrepP=NULL,diffrepN=NULL,convert_param=FALSE,pos=TRUE,tol=2,ruleset=NULL,keep_meta=TRUE, variableMetadataOutput="variableMetadata.tsv"){

  #Load the two Rdata to extract the xset objects from positive and negative mode
  cat("\tObject xset from positive mode\n")
  print(xaP)
  cat("\n")

  cat("\tObject xset from negative mode\n")
  print(xaN)
  cat("\n")

  cat("\n")
  cat("\tCombining...\n")
  #Convert the string to numeric for creating matrix
  row=as.numeric(strsplit(ruleset,",")[[1]][1])
  column=as.numeric(strsplit(ruleset,",")[[1]][2])
  ruleset=cbind(row,column)
  #Test if the file comes from an older version tool
  if ((!is.null(xaP)) & (!is.null(xaN))) {
    #Launch the combinexsannos function from CAMERA
    cAnnot=combinexsAnnos(xaP, xaN,pos=pos,tol=tol,ruleset=ruleset)
  } else {
    stop("You must relauch the CAMERA.annotate step with the lastest version.")
  }



  if(pos){
    xa=xaP
    listOFlistArgumentsP=listOFlistArguments
    mode="neg. Mode"
  } else {
    xa=xaN
    listOFlistArgumentsN=listOFlistArguments
    mode="pos. Mode"
  }
  intval = "into"; for (steps in names(listOFlistArguments)) { if (!is.null(listOFlistArguments[[steps]]$intval)) intval = listOFlistArguments[[steps]]$intval }
  peakList=getPeaklist(xa,intval=intval)
  peakList=cbind(groupnames(xa@xcmsSet),peakList); colnames(peakList)[1] = c("name");
  variableMetadata=cbind(peakList, cAnnot[, c("isotopes", "adduct", "pcgroup",mode)]);
  variableMetadata=variableMetadata[,!(colnames(variableMetadata) %in% c(sampnames(xa@xcmsSet)))]

  #Test if there are more than two classes (conditions)
  if ( nlevels(sampclass(xaP@xcmsSet))==2 & (!is.null(diffrepN)) & (!is.null(diffrepP))) {
    diffrepP = diffrepP[,c("name","fold","tstat","pvalue")]; colnames(diffrepP) = paste("P.",colnames(diffrepP),sep="")
    diffrepN = diffrepN[,c("name","fold","tstat","pvalue")]; colnames(diffrepN) = paste("N.",colnames(diffrepN),sep="")

    variableMetadata = merge(variableMetadata, diffrepP, by.x="name", by.y="P.name")
    variableMetadata = merge(variableMetadata, diffrepN, by.x="name", by.y="N.name")
  }

  rownames(variableMetadata) = NULL
  #TODO: checker
  #colnames(variableMetadata)[1:2] = c("name","mz/rt");

  #If the user want to convert the retention times (seconds) into minutes.
  if (listArguments[["convert_param"]]){
    #converting the retention times (seconds) into minutes
    cat("\tConverting the retention times into minutes\n")
    variableMetadata$rtmed=cAnnot$rt/60; variableMetadata$rtmin=cAnnot$rtmin/60; variableMetadata$rtmax=cAnnot$rtmax/60;
  }

  #If the user want to keep only the metabolites which match a difference
  if(keep_meta){
    variableMetadata=variableMetadata[variableMetadata[,c(mode)]!="",]
  }

  #Write the output into a tsv file
  write.table(variableMetadata, sep="\t", quote=FALSE, row.names=FALSE, file=variableMetadataOutput)
  return(variableMetadata);

}
